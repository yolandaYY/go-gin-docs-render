{
  "tag_service": [
    {
      "code": ")\n\ntype Tag struct {\n\tID         int\n\tName       string\n\tCreatedBy  string\n\tModifiedBy string\n\tState      int\n\n\tPageNum  int\n\tPageSize int\n}\n\nfunc (t *Tag) ExistByName() (bool, error) {\n\treturn models.ExistTagByName(t.Name)\n}\n\nfunc (t *Tag) ExistByID() (bool, error) {\n\treturn models.ExistTagByID(t.ID)\n}\n\nfunc (t *Tag) Add() error {\n\treturn models.AddTag(t.Name, t.State, t.CreatedBy)\n}\n\nfunc (t *Tag) Edit() error {\n\tdata := make(map[string]interface{})\n\tdata[\"modified_by\"] = t.ModifiedBy\n\tdata[\"name\"] = t.Name\n\tif t.State >= 0 {\n\t\tdata[\"state\"] = t.State\n\t}\n\n\treturn models.EditTag(t.ID, data)\n}\n\nfunc (t *Tag) Delete() error {\n\treturn models.DeleteTag(t.ID)\n}\n\nfunc (t *Tag) Count() (int, error) {\n\treturn models.GetTagTotal(t.getMaps())\n}\n\nfunc (t *Tag) GetAll() ([]models.Tag, error) {\n\tvar (\n\t\ttags, cacheTags []models.Tag\n\t)\n\n\tcache := cache_service.Tag{\n\t\tState: t.State,\n\n\t\tPageNum:  t.PageNum,\n\t\tPageSize: t.PageSize,\n\t}\n\tkey := cache.GetTagsKey()\n\tif gredis.Exists(key) {\n\t\tdata, err := gredis.Get(key)\n\t\tif err != nil {\n\t\t\tlogging.Info(err)\n\t\t} else {\n\t\t\tjson.Unmarshal(data, &cacheTags)\n\t\t\treturn cacheTags, nil\n\t\t}\n\t}\n\n\ttags, err := models.GetTags(t.PageNum, t.PageSize, t.getMaps())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgredis.Set(key, tags, 3600)\n\treturn tags, nil\n}\n\nfunc (t *Tag) Export() (string, error) {\n\ttags, err := t.GetAll()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\txlsFile := xlsx.NewFile()\n\tsheet, err := xlsFile.AddSheet(\"标签信息\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ttitles := []string{\"ID\", \"名称\", \"创建人\", \"创建时间\", \"修改人\", \"修改时间\"}\n\trow := sheet.AddRow()\n\n\tvar cell *xlsx.Cell\n\tfor _, title := range titles {\n\t\tcell = row.AddCell()\n\t\tcell.Value = title\n\t}\n\n\tfor _, v := range tags {\n\t\tvalues := []string{\n\t\t\tstrconv.Itoa(v.ID),\n\t\t\tv.Name,\n\t\t\tv.CreatedBy,\n\t\t\tstrconv.Itoa(v.CreatedOn),\n\t\t\tv.ModifiedBy,\n\t\t\tstrconv.Itoa(v.ModifiedOn),\n\t\t}\n\n\t\trow = sheet.AddRow()\n\t\tfor _, value := range values {\n\t\t\tcell = row.AddCell()\n\t\t\tcell.Value = value\n\t\t}\n\t}\n\n\ttime := strconv.Itoa(int(time.Now().Unix()))\n\tfilename := \"tags-\" + time + export.EXT\n\n\tdirFullPath := export.GetExcelFullPath()\n\terr = file.IsNotExistMkDir(dirFullPath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\terr = xlsFile.Save(dirFullPath + filename)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn filename, nil\n}\n\nfunc (t *Tag) Import(r io.Reader) error {\n\txlsx, err := excelize.OpenReader(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trows := xlsx.GetRows(\"标签信息\")\n\tfor irow, row := range rows {\n\t\tif irow > 0 {\n\t\t\tvar data []string\n\t\t\tfor _, cell := range row {\n\t\t\t\tdata = append(data, cell)\n\t\t\t}\n\n\t\t\tmodels.AddTag(data[1], 1, data[2])\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (t *Tag) getMaps() map[string]interface{} {\n\tmaps := make(map[string]interface{})\n\tmaps[\"deleted_on\"] = 0\n\n\tif t.Name != \"\" {\n\t\tmaps[\"name\"] = t.Name\n\t}\n\tif t.State >= 0 {\n\t\tmaps[\"state\"] = t.State\n\t}\n\n\treturn maps\n}\n",
      "depend": [
        "models",
        "pkg/export",
        "pkg/file",
        "pkg/gredis",
        "pkg/logging",
        "service/cache_service"
      ]
    }
  ],
  "cache_service": [
    {
      "code": ")\n\ntype Tag struct {\n\tID    int\n\tName  string\n\tState int\n\n\tPageNum  int\n\tPageSize int\n}\n\nfunc (t *Tag) GetTagsKey() string {\n\tkeys := []string{\n\t\te.CACHE_TAG,\n\t\t\"LIST\",\n\t}\n\n\tif t.Name != \"\" {\n\t\tkeys = append(keys, t.Name)\n\t}\n\tif t.State >= 0 {\n\t\tkeys = append(keys, strconv.Itoa(t.State))\n\t}\n\tif t.PageNum > 0 {\n\t\tkeys = append(keys, strconv.Itoa(t.PageNum))\n\t}\n\tif t.PageSize > 0 {\n\t\tkeys = append(keys, strconv.Itoa(t.PageSize))\n\t}\n\n\treturn strings.Join(keys, \"_\")\n}\n",
      "depend": [
        "pkg/e"
      ]
    },
    {
      "code": ")\n\ntype Article struct {\n\tID    int\n\tTagID int\n\tState int\n\n\tPageNum  int\n\tPageSize int\n}\n\nfunc (a *Article) GetArticleKey() string {\n\treturn e.CACHE_ARTICLE + \"_\" + strconv.Itoa(a.ID)\n}\n\nfunc (a *Article) GetArticlesKey() string {\n\tkeys := []string{\n\t\te.CACHE_ARTICLE,\n\t\t\"LIST\",\n\t}\n\n\tif a.ID > 0 {\n\t\tkeys = append(keys, strconv.Itoa(a.ID))\n\t}\n\tif a.TagID > 0 {\n\t\tkeys = append(keys, strconv.Itoa(a.TagID))\n\t}\n\tif a.State >= 0 {\n\t\tkeys = append(keys, strconv.Itoa(a.State))\n\t}\n\tif a.PageNum > 0 {\n\t\tkeys = append(keys, strconv.Itoa(a.PageNum))\n\t}\n\tif a.PageSize > 0 {\n\t\tkeys = append(keys, strconv.Itoa(a.PageSize))\n\t}\n\n\treturn strings.Join(keys, \"_\")\n}\n",
      "depend": [
        "pkg/e"
      ]
    }
  ],
  "auth_service": [
    {
      "code": "\"\n\ntype Auth struct {\n\tUsername string\n\tPassword string\n}\n\nfunc (a *Auth) Check() (bool, error) {\n\treturn models.CheckAuth(a.Username, a.Password)\n}\n",
      "depend": [
        "models"
      ]
    }
  ],
  "article_service": [
    {
      "code": ")\n\ntype ArticlePoster struct {\n\tPosterName string\n\t*Article\n\tQr *qrcode.QrCode\n}\n\nfunc NewArticlePoster(posterName string, article *Article, qr *qrcode.QrCode) *ArticlePoster {\n\treturn &ArticlePoster{\n\t\tPosterName: posterName,\n\t\tArticle:    article,\n\t\tQr:         qr,\n\t}\n}\n\nfunc GetPosterFlag() string {\n\treturn \"poster\"\n}\n\nfunc (a *ArticlePoster) CheckMergedImage(path string) bool {\n\tif file.CheckNotExist(path+a.PosterName) == true {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (a *ArticlePoster) OpenMergedImage(path string) (*os.File, error) {\n\tf, err := file.MustOpen(a.PosterName, path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn f, nil\n}\n\ntype ArticlePosterBg struct {\n\tName string\n\t*ArticlePoster\n\t*Rect\n\t*Pt\n}\n\ntype Rect struct {\n\tName string\n\tX0   int\n\tY0   int\n\tX1   int\n\tY1   int\n}\n\ntype Pt struct {\n\tX int\n\tY int\n}\n\nfunc NewArticlePosterBg(name string, ap *ArticlePoster, rect *Rect, pt *Pt) *ArticlePosterBg {\n\treturn &ArticlePosterBg{\n\t\tName:          name,\n\t\tArticlePoster: ap,\n\t\tRect:          rect,\n\t\tPt:            pt,\n\t}\n}\n\ntype DrawText struct {\n\tJPG    draw.Image\n\tMerged *os.File\n\n\tTitle string\n\tX0    int\n\tY0    int\n\tSize0 float64\n\n\tSubTitle string\n\tX1       int\n\tY1       int\n\tSize1    float64\n}\n\nfunc (a *ArticlePosterBg) DrawPoster(d *DrawText, fontName string) error {\n\tfontSource := setting.AppSetting.RuntimeRootPath + setting.AppSetting.FontSavePath + fontName\n\tfontSourceBytes, err := ioutil.ReadFile(fontSource)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttrueTypeFont, err := freetype.ParseFont(fontSourceBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfc := freetype.NewContext()\n\tfc.SetDPI(72)\n\tfc.SetFont(trueTypeFont)\n\tfc.SetFontSize(d.Size0)\n\tfc.SetClip(d.JPG.Bounds())\n\tfc.SetDst(d.JPG)\n\tfc.SetSrc(image.Black)\n\n\tpt := freetype.Pt(d.X0, d.Y0)\n\t_, err = fc.DrawString(d.Title, pt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfc.SetFontSize(d.Size1)\n\t_, err = fc.DrawString(d.SubTitle, freetype.Pt(d.X1, d.Y1))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = jpeg.Encode(d.Merged, d.JPG, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (a *ArticlePosterBg) Generate() (string, string, error) {\n\tfullPath := qrcode.GetQrCodeFullPath()\n\tfileName, path, err := a.Qr.Encode(fullPath)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tif !a.CheckMergedImage(path) {\n\t\tmergedF, err := a.OpenMergedImage(path)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\tdefer mergedF.Close()\n\n\t\tbgF, err := file.MustOpen(a.Name, path)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\tdefer bgF.Close()\n\n\t\tqrF, err := file.MustOpen(fileName, path)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\tdefer qrF.Close()\n\n\t\tbgImage, err := jpeg.Decode(bgF)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\tqrImage, err := jpeg.Decode(qrF)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\tjpg := image.NewRGBA(image.Rect(a.Rect.X0, a.Rect.Y0, a.Rect.X1, a.Rect.Y1))\n\n\t\tdraw.Draw(jpg, jpg.Bounds(), bgImage, bgImage.Bounds().Min, draw.Over)\n\t\tdraw.Draw(jpg, jpg.Bounds(), qrImage, qrImage.Bounds().Min.Sub(image.Pt(a.Pt.X, a.Pt.Y)), draw.Over)\n\n\t\terr = a.DrawPoster(&DrawText{\n\t\t\tJPG:    jpg,\n\t\t\tMerged: mergedF,\n\n\t\t\tTitle: \"Golang Gin 系列文章\",\n\t\t\tX0:    80,\n\t\t\tY0:    160,\n\t\t\tSize0: 42,\n\n\t\t\tSubTitle: \"---煎鱼\",\n\t\t\tX1:       320,\n\t\t\tY1:       220,\n\t\t\tSize1:    36,\n\t\t}, \"msyhbd.ttc\")\n\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t}\n\n\treturn fileName, path, nil\n}\n",
      "depend": [
        "pkg/file",
        "pkg/qrcode",
        "pkg/setting"
      ]
    },
    {
      "code": ")\n\ntype Article struct {\n\tID            int\n\tTagID         int\n\tTitle         string\n\tDesc          string\n\tContent       string\n\tCoverImageUrl string\n\tState         int\n\tCreatedBy     string\n\tModifiedBy    string\n\n\tPageNum  int\n\tPageSize int\n}\n\nfunc (a *Article) Add() error {\n\tarticle := map[string]interface{}{\n\t\t\"tag_id\":          a.TagID,\n\t\t\"title\":           a.Title,\n\t\t\"desc\":            a.Desc,\n\t\t\"content\":         a.Content,\n\t\t\"created_by\":      a.CreatedBy,\n\t\t\"cover_image_url\": a.CoverImageUrl,\n\t\t\"state\":           a.State,\n\t}\n\n\tif err := models.AddArticle(article); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (a *Article) Edit() error {\n\treturn models.EditArticle(a.ID, map[string]interface{}{\n\t\t\"tag_id\":          a.TagID,\n\t\t\"title\":           a.Title,\n\t\t\"desc\":            a.Desc,\n\t\t\"content\":         a.Content,\n\t\t\"cover_image_url\": a.CoverImageUrl,\n\t\t\"state\":           a.State,\n\t\t\"modified_by\":     a.ModifiedBy,\n\t})\n}\n\nfunc (a *Article) Get() (*models.Article, error) {\n\tvar cacheArticle *models.Article\n\n\tcache := cache_service.Article{ID: a.ID}\n\tkey := cache.GetArticleKey()\n\tif gredis.Exists(key) {\n\t\tdata, err := gredis.Get(key)\n\t\tif err != nil {\n\t\t\tlogging.Info(err)\n\t\t} else {\n\t\t\tjson.Unmarshal(data, &cacheArticle)\n\t\t\treturn cacheArticle, nil\n\t\t}\n\t}\n\n\tarticle, err := models.GetArticle(a.ID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgredis.Set(key, article, 3600)\n\treturn article, nil\n}\n\nfunc (a *Article) GetAll() ([]*models.Article, error) {\n\tvar (\n\t\tarticles, cacheArticles []*models.Article\n\t)\n\n\tcache := cache_service.Article{\n\t\tTagID: a.TagID,\n\t\tState: a.State,\n\n\t\tPageNum:  a.PageNum,\n\t\tPageSize: a.PageSize,\n\t}\n\tkey := cache.GetArticlesKey()\n\tif gredis.Exists(key) {\n\t\tdata, err := gredis.Get(key)\n\t\tif err != nil {\n\t\t\tlogging.Info(err)\n\t\t} else {\n\t\t\tjson.Unmarshal(data, &cacheArticles)\n\t\t\treturn cacheArticles, nil\n\t\t}\n\t}\n\n\tarticles, err := models.GetArticles(a.PageNum, a.PageSize, a.getMaps())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgredis.Set(key, articles, 3600)\n\treturn articles, nil\n}\n\nfunc (a *Article) Delete() error {\n\treturn models.DeleteArticle(a.ID)\n}\n\nfunc (a *Article) ExistByID() (bool, error) {\n\treturn models.ExistArticleByID(a.ID)\n}\n\nfunc (a *Article) Count() (int, error) {\n\treturn models.GetArticleTotal(a.getMaps())\n}\n\nfunc (a *Article) getMaps() map[string]interface{} {\n\tmaps := make(map[string]interface{})\n\tmaps[\"deleted_on\"] = 0\n\tif a.State != -1 {\n\t\tmaps[\"state\"] = a.State\n\t}\n\tif a.TagID != -1 {\n\t\tmaps[\"tag_id\"] = a.TagID\n\t}\n\n\treturn maps\n}\n",
      "depend": [
        "models",
        "pkg/gredis",
        "pkg/logging",
        "service/cache_service"
      ]
    }
  ],
  "routers": [
    {
      "code": ")\n\n// InitRouter initialize routing information\nfunc InitRouter() *gin.Engine {\n\tr := gin.New()\n\tr.Use(gin.Logger())\n\tr.Use(gin.Recovery())\n\n\tr.StaticFS(\"/export\", http.Dir(export.GetExcelFullPath()))\n\tr.StaticFS(\"/upload/images\", http.Dir(upload.GetImageFullPath()))\n\tr.StaticFS(\"/qrcode\", http.Dir(qrcode.GetQrCodeFullPath()))\n\n\tr.POST(\"/auth\", api.GetAuth)\n\tr.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\tr.POST(\"/upload\", api.UploadImage)\n\n\tapiv1 := r.Group(\"/api/v1\")\n\tapiv1.Use(jwt.JWT())\n\t{\n\t\t//获取标签列表\n\t\tapiv1.GET(\"/tags\", v1.GetTags)\n\t\t//新建标签\n\t\tapiv1.POST(\"/tags\", v1.AddTag)\n\t\t//更新指定标签\n\t\tapiv1.PUT(\"/tags/:id\", v1.EditTag)\n\t\t//删除指定标签\n\t\tapiv1.DELETE(\"/tags/:id\", v1.DeleteTag)\n\t\t//导出标签\n\t\tr.POST(\"/tags/export\", v1.ExportTag)\n\t\t//导入标签\n\t\tr.POST(\"/tags/import\", v1.ImportTag)\n\n\t\t//获取文章列表\n\t\tapiv1.GET(\"/articles\", v1.GetArticles)\n\t\t//获取指定文章\n\t\tapiv1.GET(\"/articles/:id\", v1.GetArticle)\n\t\t//新建文章\n\t\tapiv1.POST(\"/articles\", v1.AddArticle)\n\t\t//更新指定文章\n\t\tapiv1.PUT(\"/articles/:id\", v1.EditArticle)\n\t\t//删除指定文章\n\t\tapiv1.DELETE(\"/articles/:id\", v1.DeleteArticle)\n\t\t//生成文章海报\n\t\tapiv1.POST(\"/articles/poster/generate\", v1.GenerateArticlePoster)\n\t}\n\n\treturn r\n}\n",
      "depend": [
        "docs",
        "middleware/jwt",
        "pkg/export",
        "pkg/qrcode",
        "pkg/upload",
        "routers/api",
        "routers/api/v1"
      ]
    }
  ],
  "v1": [
    {
      "code": ")\n\n// @Summary Get multiple article tags\n// @Produce  json\n// @Param name query string false \"Name\"\n// @Param state query int false \"State\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/tags [get]\nfunc GetTags(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\tname := c.Query(\"name\")\n\tstate := -1\n\tif arg := c.Query(\"state\"); arg != \"\" {\n\t\tstate = com.StrTo(arg).MustInt()\n\t}\n\n\ttagService := tag_service.Tag{\n\t\tName:     name,\n\t\tState:    state,\n\t\tPageNum:  util.GetPage(c),\n\t\tPageSize: setting.AppSetting.PageSize,\n\t}\n\ttags, err := tagService.GetAll()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_GET_TAGS_FAIL, nil)\n\t\treturn\n\t}\n\n\tcount, err := tagService.Count()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_COUNT_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, map[string]interface{}{\n\t\t\"lists\": tags,\n\t\t\"total\": count,\n\t})\n}\n\ntype AddTagForm struct {\n\tName      string `form:\"name\" valid:\"Required;MaxSize(100)\"`\n\tCreatedBy string `form:\"created_by\" valid:\"Required;MaxSize(100)\"`\n\tState     int    `form:\"state\" valid:\"Range(0,1)\"`\n}\n\n// @Summary Add article tag\n// @Produce  json\n// @Param name body string true \"Name\"\n// @Param state body int false \"State\"\n// @Param created_by body int false \"CreatedBy\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/tags [post]\nfunc AddTag(c *gin.Context) {\n\tvar (\n\t\tappG = app.Gin{C: c}\n\t\tform AddTagForm\n\t)\n\n\thttpCode, errCode := app.BindAndValid(c, &form)\n\tif errCode != e.SUCCESS {\n\t\tappG.Response(httpCode, errCode, nil)\n\t\treturn\n\t}\n\n\ttagService := tag_service.Tag{\n\t\tName:      form.Name,\n\t\tCreatedBy: form.CreatedBy,\n\t\tState:     form.State,\n\t}\n\texists, err := tagService.ExistByName()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_EXIST_TAG_FAIL, nil)\n\t\treturn\n\t}\n\tif exists {\n\t\tappG.Response(http.StatusOK, e.ERROR_EXIST_TAG, nil)\n\t\treturn\n\t}\n\n\terr = tagService.Add()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_ADD_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, nil)\n}\n\ntype EditTagForm struct {\n\tID         int    `form:\"id\" valid:\"Required;Min(1)\"`\n\tName       string `form:\"name\" valid:\"Required;MaxSize(100)\"`\n\tModifiedBy string `form:\"modified_by\" valid:\"Required;MaxSize(100)\"`\n\tState      int    `form:\"state\" valid:\"Range(0,1)\"`\n}\n\n// @Summary Update article tag\n// @Produce  json\n// @Param id path int true \"ID\"\n// @Param name body string true \"Name\"\n// @Param state body int false \"State\"\n// @Param modified_by body string true \"ModifiedBy\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/tags/{id} [put]\nfunc EditTag(c *gin.Context) {\n\tvar (\n\t\tappG = app.Gin{C: c}\n\t\tform = EditTagForm{ID: com.StrTo(c.Param(\"id\")).MustInt()}\n\t)\n\n\thttpCode, errCode := app.BindAndValid(c, &form)\n\tif errCode != e.SUCCESS {\n\t\tappG.Response(httpCode, errCode, nil)\n\t\treturn\n\t}\n\n\ttagService := tag_service.Tag{\n\t\tID:         form.ID,\n\t\tName:       form.Name,\n\t\tModifiedBy: form.ModifiedBy,\n\t\tState:      form.State,\n\t}\n\n\texists, err := tagService.ExistByID()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_EXIST_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tif !exists {\n\t\tappG.Response(http.StatusOK, e.ERROR_NOT_EXIST_TAG, nil)\n\t\treturn\n\t}\n\n\terr = tagService.Edit()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_EDIT_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, nil)\n}\n\n// @Summary Delete article tag\n// @Produce  json\n// @Param id path int true \"ID\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/tags/{id} [delete]\nfunc DeleteTag(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\tvalid := validation.Validation{}\n\tid := com.StrTo(c.Param(\"id\")).MustInt()\n\tvalid.Min(id, 1, \"id\").Message(\"ID必须大于0\")\n\n\tif valid.HasErrors() {\n\t\tapp.MarkErrors(valid.Errors)\n\t\tappG.Response(http.StatusBadRequest, e.INVALID_PARAMS, nil)\n\t}\n\n\ttagService := tag_service.Tag{ID: id}\n\texists, err := tagService.ExistByID()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_EXIST_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tif !exists {\n\t\tappG.Response(http.StatusOK, e.ERROR_NOT_EXIST_TAG, nil)\n\t\treturn\n\t}\n\n\tif err := tagService.Delete(); err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_DELETE_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, nil)\n}\n\n// @Summary Export article tag\n// @Produce  json\n// @Param name body string false \"Name\"\n// @Param state body int false \"State\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/tags/export [post]\nfunc ExportTag(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\tname := c.PostForm(\"name\")\n\tstate := -1\n\tif arg := c.PostForm(\"state\"); arg != \"\" {\n\t\tstate = com.StrTo(arg).MustInt()\n\t}\n\n\ttagService := tag_service.Tag{\n\t\tName:  name,\n\t\tState: state,\n\t}\n\n\tfilename, err := tagService.Export()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_EXPORT_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, map[string]string{\n\t\t\"export_url\":      export.GetExcelFullUrl(filename),\n\t\t\"export_save_url\": export.GetExcelPath() + filename,\n\t})\n}\n\n// @Summary Import article tag\n// @Produce  json\n// @Param file body file true \"Excel File\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/tags/import [post]\nfunc ImportTag(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\n\tfile, _, err := c.Request.FormFile(\"file\")\n\tif err != nil {\n\t\tlogging.Warn(err)\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR, nil)\n\t\treturn\n\t}\n\n\ttagService := tag_service.Tag{}\n\terr = tagService.Import(file)\n\tif err != nil {\n\t\tlogging.Warn(err)\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_IMPORT_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, nil)\n}\n",
      "depend": [
        "pkg/app",
        "pkg/e",
        "pkg/export",
        "pkg/logging",
        "pkg/setting",
        "pkg/util",
        "service/tag_service"
      ]
    },
    {
      "code": ")\n\n// @Summary Get a single article\n// @Produce  json\n// @Param id path int true \"ID\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/articles/{id} [get]\nfunc GetArticle(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\tid := com.StrTo(c.Param(\"id\")).MustInt()\n\tvalid := validation.Validation{}\n\tvalid.Min(id, 1, \"id\")\n\n\tif valid.HasErrors() {\n\t\tapp.MarkErrors(valid.Errors)\n\t\tappG.Response(http.StatusBadRequest, e.INVALID_PARAMS, nil)\n\t\treturn\n\t}\n\n\tarticleService := article_service.Article{ID: id}\n\texists, err := articleService.ExistByID()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_CHECK_EXIST_ARTICLE_FAIL, nil)\n\t\treturn\n\t}\n\tif !exists {\n\t\tappG.Response(http.StatusOK, e.ERROR_NOT_EXIST_ARTICLE, nil)\n\t\treturn\n\t}\n\n\tarticle, err := articleService.Get()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_GET_ARTICLE_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, article)\n}\n\n// @Summary Get multiple articles\n// @Produce  json\n// @Param tag_id body int false \"TagID\"\n// @Param state body int false \"State\"\n// @Param created_by body int false \"CreatedBy\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/articles [get]\nfunc GetArticles(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\tvalid := validation.Validation{}\n\n\tstate := -1\n\tif arg := c.PostForm(\"state\"); arg != \"\" {\n\t\tstate = com.StrTo(arg).MustInt()\n\t\tvalid.Range(state, 0, 1, \"state\")\n\t}\n\n\ttagId := -1\n\tif arg := c.PostForm(\"tag_id\"); arg != \"\" {\n\t\ttagId = com.StrTo(arg).MustInt()\n\t\tvalid.Min(tagId, 1, \"tag_id\")\n\t}\n\n\tif valid.HasErrors() {\n\t\tapp.MarkErrors(valid.Errors)\n\t\tappG.Response(http.StatusBadRequest, e.INVALID_PARAMS, nil)\n\t\treturn\n\t}\n\n\tarticleService := article_service.Article{\n\t\tTagID:    tagId,\n\t\tState:    state,\n\t\tPageNum:  util.GetPage(c),\n\t\tPageSize: setting.AppSetting.PageSize,\n\t}\n\n\ttotal, err := articleService.Count()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_COUNT_ARTICLE_FAIL, nil)\n\t\treturn\n\t}\n\n\tarticles, err := articleService.GetAll()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_GET_ARTICLES_FAIL, nil)\n\t\treturn\n\t}\n\n\tdata := make(map[string]interface{})\n\tdata[\"lists\"] = articles\n\tdata[\"total\"] = total\n\n\tappG.Response(http.StatusOK, e.SUCCESS, data)\n}\n\ntype AddArticleForm struct {\n\tTagID         int    `form:\"tag_id\" valid:\"Required;Min(1)\"`\n\tTitle         string `form:\"title\" valid:\"Required;MaxSize(100)\"`\n\tDesc          string `form:\"desc\" valid:\"Required;MaxSize(255)\"`\n\tContent       string `form:\"content\" valid:\"Required;MaxSize(65535)\"`\n\tCreatedBy     string `form:\"created_by\" valid:\"Required;MaxSize(100)\"`\n\tCoverImageUrl string `form:\"cover_image_url\" valid:\"Required;MaxSize(255)\"`\n\tState         int    `form:\"state\" valid:\"Range(0,1)\"`\n}\n\n// @Summary Add article\n// @Produce  json\n// @Param tag_id body int true \"TagID\"\n// @Param title body string true \"Title\"\n// @Param desc body string true \"Desc\"\n// @Param content body string true \"Content\"\n// @Param created_by body string true \"CreatedBy\"\n// @Param state body int true \"State\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/articles [post]\nfunc AddArticle(c *gin.Context) {\n\tvar (\n\t\tappG = app.Gin{C: c}\n\t\tform AddArticleForm\n\t)\n\n\thttpCode, errCode := app.BindAndValid(c, &form)\n\tif errCode != e.SUCCESS {\n\t\tappG.Response(httpCode, errCode, nil)\n\t\treturn\n\t}\n\n\ttagService := tag_service.Tag{ID: form.TagID}\n\texists, err := tagService.ExistByID()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_EXIST_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tif !exists {\n\t\tappG.Response(http.StatusOK, e.ERROR_NOT_EXIST_TAG, nil)\n\t\treturn\n\t}\n\n\tarticleService := article_service.Article{\n\t\tTagID:         form.TagID,\n\t\tTitle:         form.Title,\n\t\tDesc:          form.Desc,\n\t\tContent:       form.Content,\n\t\tCoverImageUrl: form.CoverImageUrl,\n\t\tState:         form.State,\n\t\tCreatedBy:     form.CreatedBy,\n\t}\n\tif err := articleService.Add(); err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_ADD_ARTICLE_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, nil)\n}\n\ntype EditArticleForm struct {\n\tID            int    `form:\"id\" valid:\"Required;Min(1)\"`\n\tTagID         int    `form:\"tag_id\" valid:\"Required;Min(1)\"`\n\tTitle         string `form:\"title\" valid:\"Required;MaxSize(100)\"`\n\tDesc          string `form:\"desc\" valid:\"Required;MaxSize(255)\"`\n\tContent       string `form:\"content\" valid:\"Required;MaxSize(65535)\"`\n\tModifiedBy    string `form:\"modified_by\" valid:\"Required;MaxSize(100)\"`\n\tCoverImageUrl string `form:\"cover_image_url\" valid:\"Required;MaxSize(255)\"`\n\tState         int    `form:\"state\" valid:\"Range(0,1)\"`\n}\n\n// @Summary Update article\n// @Produce  json\n// @Param id path int true \"ID\"\n// @Param tag_id body string false \"TagID\"\n// @Param title body string false \"Title\"\n// @Param desc body string false \"Desc\"\n// @Param content body string false \"Content\"\n// @Param modified_by body string true \"ModifiedBy\"\n// @Param state body int false \"State\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/articles/{id} [put]\nfunc EditArticle(c *gin.Context) {\n\tvar (\n\t\tappG = app.Gin{C: c}\n\t\tform = EditArticleForm{ID: com.StrTo(c.Param(\"id\")).MustInt()}\n\t)\n\n\thttpCode, errCode := app.BindAndValid(c, &form)\n\tif errCode != e.SUCCESS {\n\t\tappG.Response(httpCode, errCode, nil)\n\t\treturn\n\t}\n\n\tarticleService := article_service.Article{\n\t\tID:            form.ID,\n\t\tTagID:         form.TagID,\n\t\tTitle:         form.Title,\n\t\tDesc:          form.Desc,\n\t\tContent:       form.Content,\n\t\tCoverImageUrl: form.CoverImageUrl,\n\t\tModifiedBy:    form.ModifiedBy,\n\t\tState:         form.State,\n\t}\n\texists, err := articleService.ExistByID()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_CHECK_EXIST_ARTICLE_FAIL, nil)\n\t\treturn\n\t}\n\tif !exists {\n\t\tappG.Response(http.StatusOK, e.ERROR_NOT_EXIST_ARTICLE, nil)\n\t\treturn\n\t}\n\n\ttagService := tag_service.Tag{ID: form.TagID}\n\texists, err = tagService.ExistByID()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_EXIST_TAG_FAIL, nil)\n\t\treturn\n\t}\n\n\tif !exists {\n\t\tappG.Response(http.StatusOK, e.ERROR_NOT_EXIST_TAG, nil)\n\t\treturn\n\t}\n\n\terr = articleService.Edit()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_EDIT_ARTICLE_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, nil)\n}\n\n// @Summary Delete article\n// @Produce  json\n// @Param id path int true \"ID\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/articles/{id} [delete]\nfunc DeleteArticle(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\tvalid := validation.Validation{}\n\tid := com.StrTo(c.Param(\"id\")).MustInt()\n\tvalid.Min(id, 1, \"id\").Message(\"ID必须大于0\")\n\n\tif valid.HasErrors() {\n\t\tapp.MarkErrors(valid.Errors)\n\t\tappG.Response(http.StatusOK, e.INVALID_PARAMS, nil)\n\t\treturn\n\t}\n\n\tarticleService := article_service.Article{ID: id}\n\texists, err := articleService.ExistByID()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_CHECK_EXIST_ARTICLE_FAIL, nil)\n\t\treturn\n\t}\n\tif !exists {\n\t\tappG.Response(http.StatusOK, e.ERROR_NOT_EXIST_ARTICLE, nil)\n\t\treturn\n\t}\n\n\terr = articleService.Delete()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_DELETE_ARTICLE_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, nil)\n}\n\nconst (\n\tQRCODE_URL = \"https://github.com/EDDYCJY/blog#gin%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95\"\n)\n\nfunc GenerateArticlePoster(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\tarticle := &article_service.Article{}\n\tqr := qrcode.NewQrCode(QRCODE_URL, 300, 300, qr.M, qr.Auto)\n\tposterName := article_service.GetPosterFlag() + \"-\" + qrcode.GetQrCodeFileName(qr.URL) + qr.GetQrCodeExt()\n\tarticlePoster := article_service.NewArticlePoster(posterName, article, qr)\n\tarticlePosterBgService := article_service.NewArticlePosterBg(\n\t\t\"bg.jpg\",\n\t\tarticlePoster,\n\t\t&article_service.Rect{\n\t\t\tX0: 0,\n\t\t\tY0: 0,\n\t\t\tX1: 550,\n\t\t\tY1: 700,\n\t\t},\n\t\t&article_service.Pt{\n\t\t\tX: 125,\n\t\t\tY: 298,\n\t\t},\n\t)\n\n\t_, filePath, err := articlePosterBgService.Generate()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_GEN_ARTICLE_POSTER_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, map[string]string{\n\t\t\"poster_url\":      qrcode.GetQrCodeFullUrl(posterName),\n\t\t\"poster_save_url\": filePath + posterName,\n\t})\n}\n",
      "depend": [
        "pkg/app",
        "pkg/e",
        "pkg/qrcode",
        "pkg/setting",
        "pkg/util",
        "service/article_service",
        "service/tag_service"
      ]
    }
  ],
  "api": [
    {
      "code": ")\n\n// @Summary Import Image\n// @Produce  json\n// @Param image formData file true \"Image File\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /api/v1/tags/import [post]\nfunc UploadImage(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\tfile, image, err := c.Request.FormFile(\"image\")\n\tif err != nil {\n\t\tlogging.Warn(err)\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR, nil)\n\t\treturn\n\t}\n\n\tif image == nil {\n\t\tappG.Response(http.StatusBadRequest, e.INVALID_PARAMS, nil)\n\t\treturn\n\t}\n\n\timageName := upload.GetImageName(image.Filename)\n\tfullPath := upload.GetImageFullPath()\n\tsavePath := upload.GetImagePath()\n\tsrc := fullPath + imageName\n\n\tif !upload.CheckImageExt(imageName) || !upload.CheckImageSize(file) {\n\t\tappG.Response(http.StatusBadRequest, e.ERROR_UPLOAD_CHECK_IMAGE_FORMAT, nil)\n\t\treturn\n\t}\n\n\terr = upload.CheckImage(fullPath)\n\tif err != nil {\n\t\tlogging.Warn(err)\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_UPLOAD_CHECK_IMAGE_FAIL, nil)\n\t\treturn\n\t}\n\n\tif err := c.SaveUploadedFile(image, src); err != nil {\n\t\tlogging.Warn(err)\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_UPLOAD_SAVE_IMAGE_FAIL, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, map[string]string{\n\t\t\"image_url\":      upload.GetImageFullUrl(imageName),\n\t\t\"image_save_url\": savePath + imageName,\n\t})\n}\n",
      "depend": [
        "pkg/app",
        "pkg/e",
        "pkg/logging",
        "pkg/upload"
      ]
    },
    {
      "code": ")\n\ntype auth struct {\n\tUsername string `valid:\"Required; MaxSize(50)\"`\n\tPassword string `valid:\"Required; MaxSize(50)\"`\n}\n\n// @Summary Get Auth\n// @Produce  json\n// @Param username query string true \"userName\"\n// @Param password query string true \"password\"\n// @Success 200 {object} app.Response\n// @Failure 500 {object} app.Response\n// @Router /auth [get]\nfunc GetAuth(c *gin.Context) {\n\tappG := app.Gin{C: c}\n\tvalid := validation.Validation{}\n\n\tusername := c.PostForm(\"username\")\n\tpassword := c.PostForm(\"password\")\n\n\ta := auth{Username: username, Password: password}\n\tok, _ := valid.Valid(&a)\n\n\tif !ok {\n\t\tapp.MarkErrors(valid.Errors)\n\t\tappG.Response(http.StatusBadRequest, e.INVALID_PARAMS, nil)\n\t\treturn\n\t}\n\n\tauthService := auth_service.Auth{Username: username, Password: password}\n\tisExist, err := authService.Check()\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_AUTH_CHECK_TOKEN_FAIL, nil)\n\t\treturn\n\t}\n\n\tif !isExist {\n\t\tappG.Response(http.StatusUnauthorized, e.ERROR_AUTH, nil)\n\t\treturn\n\t}\n\n\ttoken, err := util.GenerateToken(username, password)\n\tif err != nil {\n\t\tappG.Response(http.StatusInternalServerError, e.ERROR_AUTH_TOKEN, nil)\n\t\treturn\n\t}\n\n\tappG.Response(http.StatusOK, e.SUCCESS, map[string]string{\n\t\t\"token\": token,\n\t})\n}\n",
      "depend": [
        "pkg/app",
        "pkg/e",
        "pkg/util",
        "service/auth_service"
      ]
    }
  ],
  "util": [
    {
      "code": "\"\n\n// Setup Initialize the util\nfunc Setup() {\n\tjwtSecret = []byte(setting.AppSetting.JwtSecret)\n}",
      "depend": [
        "pkg/setting"
      ]
    },
    {
      "code": ")\n\n// GetPage get page parameters\nfunc GetPage(c *gin.Context) int {\n\tresult := 0\n\tpage := com.StrTo(c.Query(\"page\")).MustInt()\n\tif page > 0 {\n\t\tresult = (page - 1) * setting.AppSetting.PageSize\n\t}\n\n\treturn result\n}\n",
      "depend": [
        "pkg/setting"
      ]
    },
    {
      "code": ")\n\n// EncodeMD5 md5 encryption\nfunc EncodeMD5(value string) string {\n\tm := md5.New()\n\tm.Write([]byte(value))\n\n\treturn hex.EncodeToString(m.Sum(nil))\n}\n",
      "depend": []
    },
    {
      "code": ")\n\nvar jwtSecret []byte\n\ntype Claims struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n\tjwt.StandardClaims\n}\n\n// GenerateToken generate tokens used for auth\nfunc GenerateToken(username, password string) (string, error) {\n\tnowTime := time.Now()\n\texpireTime := nowTime.Add(3 * time.Hour)\n\n\tclaims := Claims{\n\t\tEncodeMD5(username),\n\t\tEncodeMD5(password),\n\t\tjwt.StandardClaims{\n\t\t\tExpiresAt: expireTime.Unix(),\n\t\t\tIssuer:    \"gin-blog\",\n\t\t},\n\t}\n\n\ttokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttoken, err := tokenClaims.SignedString(jwtSecret)\n\n\treturn token, err\n}\n\n// ParseToken parsing token\nfunc ParseToken(token string) (*Claims, error) {\n\ttokenClaims, err := jwt.ParseWithClaims(token, &Claims{}, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecret, nil\n\t})\n\n\tif tokenClaims != nil {\n\t\tif claims, ok := tokenClaims.Claims.(*Claims); ok && tokenClaims.Valid {\n\t\t\treturn claims, nil\n\t\t}\n\t}\n\n\treturn nil, err\n}\n",
      "depend": []
    }
  ],
  "upload": [
    {
      "code": ")\n\n// GetImageFullUrl get the full access path\nfunc GetImageFullUrl(name string) string {\n\treturn setting.AppSetting.PrefixUrl + \"/\" + GetImagePath() + name\n}\n\n// GetImageName get image name\nfunc GetImageName(name string) string {\n\text := path.Ext(name)\n\tfileName := strings.TrimSuffix(name, ext)\n\tfileName = util.EncodeMD5(fileName)\n\n\treturn fileName + ext\n}\n\n// GetImagePath get save path\nfunc GetImagePath() string {\n\treturn setting.AppSetting.ImageSavePath\n}\n\n// GetImageFullPath get full save path\nfunc GetImageFullPath() string {\n\treturn setting.AppSetting.RuntimeRootPath + GetImagePath()\n}\n\n// CheckImageExt check image file ext\nfunc CheckImageExt(fileName string) bool {\n\text := file.GetExt(fileName)\n\tfor _, allowExt := range setting.AppSetting.ImageAllowExts {\n\t\tif strings.ToUpper(allowExt) == strings.ToUpper(ext) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// CheckImageSize check image size\nfunc CheckImageSize(f multipart.File) bool {\n\tsize, err := file.GetSize(f)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tlogging.Warn(err)\n\t\treturn false\n\t}\n\n\treturn size <= setting.AppSetting.ImageMaxSize\n}\n\n// CheckImage check if the file exists\nfunc CheckImage(src string) error {\n\tdir, err := os.Getwd()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"os.Getwd err: %v\", err)\n\t}\n\n\terr = file.IsNotExistMkDir(dir + \"/\" + src)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"file.IsNotExistMkDir err: %v\", err)\n\t}\n\n\tperm := file.CheckPermission(src)\n\tif perm == true {\n\t\treturn fmt.Errorf(\"file.CheckPermission Permission denied src: %s\", src)\n\t}\n\n\treturn nil\n}\n",
      "depend": [
        "pkg/file",
        "pkg/logging",
        "pkg/setting",
        "pkg/util"
      ]
    }
  ],
  "setting": [
    {
      "code": ")\n\ntype App struct {\n\tJwtSecret string\n\tPageSize  int\n\tPrefixUrl string\n\n\tRuntimeRootPath string\n\n\tImageSavePath  string\n\tImageMaxSize   int\n\tImageAllowExts []string\n\n\tExportSavePath string\n\tQrCodeSavePath string\n\tFontSavePath   string\n\n\tLogSavePath string\n\tLogSaveName string\n\tLogFileExt  string\n\tTimeFormat  string\n}\n\nvar AppSetting = &App{}\n\ntype Server struct {\n\tRunMode      string\n\tHttpPort     int\n\tReadTimeout  time.Duration\n\tWriteTimeout time.Duration\n}\n\nvar ServerSetting = &Server{}\n\ntype Database struct {\n\tType        string\n\tUser        string\n\tPassword    string\n\tHost        string\n\tName        string\n\tTablePrefix string\n}\n\nvar DatabaseSetting = &Database{}\n\ntype Redis struct {\n\tHost        string\n\tPassword    string\n\tMaxIdle     int\n\tMaxActive   int\n\tIdleTimeout time.Duration\n}\n\nvar RedisSetting = &Redis{}\n\nvar cfg *ini.File\n\n// Setup initialize the configuration instance\nfunc Setup() {\n\tvar err error\n\tcfg, err = ini.Load(\"conf/app.ini\")\n\tif err != nil {\n\t\tlog.Fatalf(\"setting.Setup, fail to parse 'conf/app.ini': %v\", err)\n\t}\n\n\tmapTo(\"app\", AppSetting)\n\tmapTo(\"server\", ServerSetting)\n\tmapTo(\"database\", DatabaseSetting)\n\tmapTo(\"redis\", RedisSetting)\n\n\tAppSetting.ImageMaxSize = AppSetting.ImageMaxSize * 1024 * 1024\n\tServerSetting.ReadTimeout = ServerSetting.ReadTimeout * time.Second\n\tServerSetting.WriteTimeout = ServerSetting.WriteTimeout * time.Second\n\tRedisSetting.IdleTimeout = RedisSetting.IdleTimeout * time.Second\n}\n\n// mapTo map section\nfunc mapTo(section string, v interface{}) {\n\terr := cfg.Section(section).MapTo(v)\n\tif err != nil {\n\t\tlog.Fatalf(\"Cfg.MapTo %s err: %v\", section, err)\n\t}\n}\n",
      "depend": []
    }
  ],
  "qrcode": [
    {
      "code": ")\n\ntype QrCode struct {\n\tURL    string\n\tWidth  int\n\tHeight int\n\tExt    string\n\tLevel  qr.ErrorCorrectionLevel\n\tMode   qr.Encoding\n}\n\nconst (\n\tEXT_JPG = \".jpg\"\n)\n\n// NewQrCode initialize instance\nfunc NewQrCode(url string, width, height int, level qr.ErrorCorrectionLevel, mode qr.Encoding) *QrCode {\n\treturn &QrCode{\n\t\tURL:    url,\n\t\tWidth:  width,\n\t\tHeight: height,\n\t\tLevel:  level,\n\t\tMode:   mode,\n\t\tExt:    EXT_JPG,\n\t}\n}\n\n// GetQrCodePath get save path\nfunc GetQrCodePath() string {\n\treturn setting.AppSetting.QrCodeSavePath\n}\n\n// GetQrCodeFullPath get full save path\nfunc GetQrCodeFullPath() string {\n\treturn setting.AppSetting.RuntimeRootPath + setting.AppSetting.QrCodeSavePath\n}\n\n// GetQrCodeFullUrl get the full access path\nfunc GetQrCodeFullUrl(name string) string {\n\treturn setting.AppSetting.PrefixUrl + \"/\" + GetQrCodePath() + name\n}\n\n// GetQrCodeFileName get qr file name\nfunc GetQrCodeFileName(value string) string {\n\treturn util.EncodeMD5(value)\n}\n\n// GetQrCodeExt get qr file ext\nfunc (q *QrCode) GetQrCodeExt() string {\n\treturn q.Ext\n}\n\n// Encode generate QR code\nfunc (q *QrCode) Encode(path string) (string, string, error) {\n\tname := GetQrCodeFileName(q.URL) + q.GetQrCodeExt()\n\tsrc := path + name\n\tif file.CheckNotExist(src) == true {\n\t\tcode, err := qr.Encode(q.URL, q.Level, q.Mode)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\tcode, err = barcode.Scale(code, q.Width, q.Height)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\tf, err := file.MustOpen(name, path)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\tdefer f.Close()\n\n\t\terr = jpeg.Encode(f, code, nil)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t}\n\n\treturn name, path, nil\n}\n",
      "depend": [
        "pkg/file",
        "pkg/setting",
        "pkg/util"
      ]
    }
  ],
  "logging": [
    {
      "code": ")\n\ntype Level int\n\nvar (\n\tF *os.File\n\n\tDefaultPrefix      = \"\"\n\tDefaultCallerDepth = 2\n\n\tlogger     *log.Logger\n\tlogPrefix  = \"\"\n\tlevelFlags = []string{\"DEBUG\", \"INFO\", \"WARN\", \"ERROR\", \"FATAL\"}\n)\n\nconst (\n\tDEBUG Level = iota\n\tINFO\n\tWARNING\n\tERROR\n\tFATAL\n)\n\n// Setup initialize the log instance\nfunc Setup() {\n\tvar err error\n\tfilePath := getLogFilePath()\n\tfileName := getLogFileName()\n\tF, err = file.MustOpen(fileName, filePath)\n\tif err != nil {\n\t\tlog.Fatalf(\"logging.Setup err: %v\", err)\n\t}\n\n\tlogger = log.New(F, DefaultPrefix, log.LstdFlags)\n}\n\n// Debug output logs at debug level\nfunc Debug(v ...interface{}) {\n\tsetPrefix(DEBUG)\n\tlogger.Println(v)\n}\n\n// Info output logs at info level\nfunc Info(v ...interface{}) {\n\tsetPrefix(INFO)\n\tlogger.Println(v)\n}\n\n// Warn output logs at warn level\nfunc Warn(v ...interface{}) {\n\tsetPrefix(WARNING)\n\tlogger.Println(v)\n}\n\n// Error output logs at error level\nfunc Error(v ...interface{}) {\n\tsetPrefix(ERROR)\n\tlogger.Println(v)\n}\n\n// Fatal output logs at fatal level\nfunc Fatal(v ...interface{}) {\n\tsetPrefix(FATAL)\n\tlogger.Fatalln(v)\n}\n\n// setPrefix set the prefix of the log output\nfunc setPrefix(level Level) {\n\t_, file, line, ok := runtime.Caller(DefaultCallerDepth)\n\tif ok {\n\t\tlogPrefix = fmt.Sprintf(\"[%s][%s:%d]\", levelFlags[level], filepath.Base(file), line)\n\t} else {\n\t\tlogPrefix = fmt.Sprintf(\"[%s]\", levelFlags[level])\n\t}\n\n\tlogger.SetPrefix(logPrefix)\n}\n",
      "depend": [
        "pkg/file"
      ]
    },
    {
      "code": ")\n\n// getLogFilePath get the log file save path\nfunc getLogFilePath() string {\n\treturn fmt.Sprintf(\"%s%s\", setting.AppSetting.RuntimeRootPath, setting.AppSetting.LogSavePath)\n}\n\n// getLogFileName get the save name of the log file\nfunc getLogFileName() string {\n\treturn fmt.Sprintf(\"%s%s.%s\",\n\t\tsetting.AppSetting.LogSaveName,\n\t\ttime.Now().Format(setting.AppSetting.TimeFormat),\n\t\tsetting.AppSetting.LogFileExt,\n\t)\n}\n",
      "depend": [
        "pkg/setting"
      ]
    }
  ],
  "gredis": [
    {
      "code": ")\n\nvar RedisConn *redis.Pool\n\n// Setup Initialize the Redis instance\nfunc Setup() error {\n\tRedisConn = &redis.Pool{\n\t\tMaxIdle:     setting.RedisSetting.MaxIdle,\n\t\tMaxActive:   setting.RedisSetting.MaxActive,\n\t\tIdleTimeout: setting.RedisSetting.IdleTimeout,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.Dial(\"tcp\", setting.RedisSetting.Host)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif setting.RedisSetting.Password != \"\" {\n\t\t\t\tif _, err := c.Do(\"AUTH\", setting.RedisSetting.Password); err != nil {\n\t\t\t\t\tc.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c, err\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\t_, err := c.Do(\"PING\")\n\t\t\treturn err\n\t\t},\n\t}\n\n\treturn nil\n}\n\n// Set a key/value\nfunc Set(key string, data interface{}, time int) error {\n\tconn := RedisConn.Get()\n\tdefer conn.Close()\n\n\tvalue, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = conn.Do(\"SET\", key, value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = conn.Do(\"EXPIRE\", key, time)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Exists check a key\nfunc Exists(key string) bool {\n\tconn := RedisConn.Get()\n\tdefer conn.Close()\n\n\texists, err := redis.Bool(conn.Do(\"EXISTS\", key))\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn exists\n}\n\n// Get get a key\nfunc Get(key string) ([]byte, error) {\n\tconn := RedisConn.Get()\n\tdefer conn.Close()\n\n\treply, err := redis.Bytes(conn.Do(\"GET\", key))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn reply, nil\n}\n\n// Delete delete a kye\nfunc Delete(key string) (bool, error) {\n\tconn := RedisConn.Get()\n\tdefer conn.Close()\n\n\treturn redis.Bool(conn.Do(\"DEL\", key))\n}\n\n// LikeDeletes batch delete\nfunc LikeDeletes(key string) error {\n\tconn := RedisConn.Get()\n\tdefer conn.Close()\n\n\tkeys, err := redis.Strings(conn.Do(\"KEYS\", \"*\"+key+\"*\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, key := range keys {\n\t\t_, err = Delete(key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "depend": [
        "pkg/setting"
      ]
    }
  ],
  "file": [
    {
      "code": ")\n\n// GetSize get the file size\nfunc GetSize(f multipart.File) (int, error) {\n\tcontent, err := ioutil.ReadAll(f)\n\n\treturn len(content), err\n}\n\n// GetExt get the file ext\nfunc GetExt(fileName string) string {\n\treturn path.Ext(fileName)\n}\n\n// CheckNotExist check if the file exists\nfunc CheckNotExist(src string) bool {\n\t_, err := os.Stat(src)\n\n\treturn os.IsNotExist(err)\n}\n\n// CheckPermission check if the file has permission\nfunc CheckPermission(src string) bool {\n\t_, err := os.Stat(src)\n\n\treturn os.IsPermission(err)\n}\n\n// IsNotExistMkDir create a directory if it does not exist\nfunc IsNotExistMkDir(src string) error {\n\tif notExist := CheckNotExist(src); notExist == true {\n\t\tif err := MkDir(src); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MkDir create a directory\nfunc MkDir(src string) error {\n\terr := os.MkdirAll(src, os.ModePerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Open a file according to a specific mode\nfunc Open(name string, flag int, perm os.FileMode) (*os.File, error) {\n\tf, err := os.OpenFile(name, flag, perm)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn f, nil\n}\n\n// MustOpen maximize trying to open the file\nfunc MustOpen(fileName, filePath string) (*os.File, error) {\n\tdir, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"os.Getwd err: %v\", err)\n\t}\n\n\tsrc := dir + \"/\" + filePath\n\tperm := CheckPermission(src)\n\tif perm == true {\n\t\treturn nil, fmt.Errorf(\"file.CheckPermission Permission denied src: %s\", src)\n\t}\n\n\terr = IsNotExistMkDir(src)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"file.IsNotExistMkDir src: %s, err: %v\", src, err)\n\t}\n\n\tf, err := Open(src+fileName, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0644)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Fail to OpenFile :%v\", err)\n\t}\n\n\treturn f, nil\n}\n",
      "depend": []
    }
  ],
  "export": [
    {
      "code": "\"\n\nconst EXT = \".xlsx\"\n\n// GetExcelFullUrl get the full access path of the Excel file\nfunc GetExcelFullUrl(name string) string {\n\treturn setting.AppSetting.PrefixUrl + \"/\" + GetExcelPath() + name\n}\n\n// GetExcelPath get the relative save path of the Excel file\nfunc GetExcelPath() string {\n\treturn setting.AppSetting.ExportSavePath\n}\n\n// GetExcelFullPath Get the full save path of the Excel file\nfunc GetExcelFullPath() string {\n\treturn setting.AppSetting.RuntimeRootPath + GetExcelPath()\n}\n",
      "depend": [
        "pkg/setting"
      ]
    }
  ],
  "e": [
    {
      "code": "\n\nvar MsgFlags = map[int]string{\n\tSUCCESS:                         \"ok\",\n\tERROR:                           \"fail\",\n\tINVALID_PARAMS:                  \"请求参数错误\",\n\tERROR_EXIST_TAG:                 \"已存在该标签名称\",\n\tERROR_EXIST_TAG_FAIL:            \"获取已存在标签失败\",\n\tERROR_NOT_EXIST_TAG:             \"该标签不存在\",\n\tERROR_GET_TAGS_FAIL:             \"获取所有标签失败\",\n\tERROR_COUNT_TAG_FAIL:            \"统计标签失败\",\n\tERROR_ADD_TAG_FAIL:              \"新增标签失败\",\n\tERROR_EDIT_TAG_FAIL:             \"修改标签失败\",\n\tERROR_DELETE_TAG_FAIL:           \"删除标签失败\",\n\tERROR_EXPORT_TAG_FAIL:           \"导出标签失败\",\n\tERROR_IMPORT_TAG_FAIL:           \"导入标签失败\",\n\tERROR_NOT_EXIST_ARTICLE:         \"该文章不存在\",\n\tERROR_ADD_ARTICLE_FAIL:          \"新增文章失败\",\n\tERROR_DELETE_ARTICLE_FAIL:       \"删除文章失败\",\n\tERROR_CHECK_EXIST_ARTICLE_FAIL:  \"检查文章是否存在失败\",\n\tERROR_EDIT_ARTICLE_FAIL:         \"修改文章失败\",\n\tERROR_COUNT_ARTICLE_FAIL:        \"统计文章失败\",\n\tERROR_GET_ARTICLES_FAIL:         \"获取多个文章失败\",\n\tERROR_GET_ARTICLE_FAIL:          \"获取单个文章失败\",\n\tERROR_GEN_ARTICLE_POSTER_FAIL:   \"生成文章海报失败\",\n\tERROR_AUTH_CHECK_TOKEN_FAIL:     \"Token鉴权失败\",\n\tERROR_AUTH_CHECK_TOKEN_TIMEOUT:  \"Token已超时\",\n\tERROR_AUTH_TOKEN:                \"Token生成失败\",\n\tERROR_AUTH:                      \"Token错误\",\n\tERROR_UPLOAD_SAVE_IMAGE_FAIL:    \"保存图片失败\",\n\tERROR_UPLOAD_CHECK_IMAGE_FAIL:   \"检查图片失败\",\n\tERROR_UPLOAD_CHECK_IMAGE_FORMAT: \"校验图片错误，图片格式或大小有问题\",\n}\n\n// GetMsg get error information based on Code\nfunc GetMsg(code int) string {\n\tmsg, ok := MsgFlags[code]\n\tif ok {\n\t\treturn msg\n\t}\n\n\treturn MsgFlags[ERROR]\n}\n",
      "depend": []
    },
    {
      "code": "\n\nconst (\n\tSUCCESS        = 200\n\tERROR          = 500\n\tINVALID_PARAMS = 400\n\n\tERROR_EXIST_TAG       = 10001\n\tERROR_EXIST_TAG_FAIL  = 10002\n\tERROR_NOT_EXIST_TAG   = 10003\n\tERROR_GET_TAGS_FAIL   = 10004\n\tERROR_COUNT_TAG_FAIL  = 10005\n\tERROR_ADD_TAG_FAIL    = 10006\n\tERROR_EDIT_TAG_FAIL   = 10007\n\tERROR_DELETE_TAG_FAIL = 10008\n\tERROR_EXPORT_TAG_FAIL = 10009\n\tERROR_IMPORT_TAG_FAIL = 10010\n\n\tERROR_NOT_EXIST_ARTICLE        = 10011\n\tERROR_CHECK_EXIST_ARTICLE_FAIL = 10012\n\tERROR_ADD_ARTICLE_FAIL         = 10013\n\tERROR_DELETE_ARTICLE_FAIL      = 10014\n\tERROR_EDIT_ARTICLE_FAIL        = 10015\n\tERROR_COUNT_ARTICLE_FAIL       = 10016\n\tERROR_GET_ARTICLES_FAIL        = 10017\n\tERROR_GET_ARTICLE_FAIL         = 10018\n\tERROR_GEN_ARTICLE_POSTER_FAIL  = 10019\n\n\tERROR_AUTH_CHECK_TOKEN_FAIL    = 20001\n\tERROR_AUTH_CHECK_TOKEN_TIMEOUT = 20002\n\tERROR_AUTH_TOKEN               = 20003\n\tERROR_AUTH                     = 20004\n\n\tERROR_UPLOAD_SAVE_IMAGE_FAIL    = 30001\n\tERROR_UPLOAD_CHECK_IMAGE_FAIL   = 30002\n\tERROR_UPLOAD_CHECK_IMAGE_FORMAT = 30003\n)\n",
      "depend": []
    },
    {
      "code": "\n\nconst (\n\tCACHE_ARTICLE = \"ARTICLE\"\n\tCACHE_TAG     = \"TAG\"\n)\n",
      "depend": []
    }
  ],
  "app": [
    {
      "code": ")\n\ntype Gin struct {\n\tC *gin.Context\n}\n\ntype Response struct {\n\tCode int         `json:\"code\"`\n\tMsg  string      `json:\"msg\"`\n\tData interface{} `json:\"data\"`\n}\n\n// Response setting gin.JSON\nfunc (g *Gin) Response(httpCode, errCode int, data interface{}) {\n\tg.C.JSON(httpCode, Response{\n\t\tCode: errCode,\n\t\tMsg:  e.GetMsg(errCode),\n\t\tData: data,\n\t})\n\treturn\n}\n",
      "depend": [
        "pkg/e"
      ]
    },
    {
      "code": ")\n\n// MarkErrors logs error logs\nfunc MarkErrors(errors []*validation.Error) {\n\tfor _, err := range errors {\n\t\tlogging.Info(err.Key, err.Message)\n\t}\n\n\treturn\n}\n",
      "depend": [
        "pkg/logging"
      ]
    },
    {
      "code": ")\n\n// BindAndValid binds and validates data\nfunc BindAndValid(c *gin.Context, form interface{}) (int, int) {\n\terr := c.Bind(form)\n\tif err != nil {\n\t\treturn http.StatusBadRequest, e.INVALID_PARAMS\n\t}\n\n\tvalid := validation.Validation{}\n\tcheck, err := valid.Valid(form)\n\tif err != nil {\n\t\treturn http.StatusInternalServerError, e.ERROR\n\t}\n\tif !check {\n\t\tMarkErrors(valid.Errors)\n\t\treturn http.StatusBadRequest, e.INVALID_PARAMS\n\t}\n\n\treturn http.StatusOK, e.SUCCESS\n}\n",
      "depend": [
        "pkg/e"
      ]
    }
  ],
  "models": [
    {
      "code": ")\n\ntype Tag struct {\n\tModel\n\n\tName       string `json:\"name\"`\n\tCreatedBy  string `json:\"created_by\"`\n\tModifiedBy string `json:\"modified_by\"`\n\tState      int    `json:\"state\"`\n}\n\n// ExistTagByName checks if there is a tag with the same name\nfunc ExistTagByName(name string) (bool, error) {\n\tvar tag Tag\n\terr := db.Select(\"id\").Where(\"name = ? AND deleted_on = ? \", name, 0).First(&tag).Error\n\tif err != nil && err != gorm.ErrRecordNotFound {\n\t\treturn false, err\n\t}\n\n\tif tag.ID > 0 {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// AddTag Add a Tag\nfunc AddTag(name string, state int, createdBy string) error {\n\ttag := Tag{\n\t\tName:      name,\n\t\tState:     state,\n\t\tCreatedBy: createdBy,\n\t}\n\tif err := db.Create(&tag).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// GetTags gets a list of tags based on paging and constraints\nfunc GetTags(pageNum int, pageSize int, maps interface{}) ([]Tag, error) {\n\tvar (\n\t\ttags []Tag\n\t\terr  error\n\t)\n\n\tif pageSize > 0 && pageNum > 0 {\n\t\terr = db.Where(maps).Find(&tags).Offset(pageNum).Limit(pageSize).Error\n\t} else {\n\t\terr = db.Where(maps).Find(&tags).Error\n\t}\n\n\tif err != nil && err != gorm.ErrRecordNotFound {\n\t\treturn nil, err\n\t}\n\n\treturn tags, nil\n}\n\n// GetTagTotal counts the total number of tags based on the constraint\nfunc GetTagTotal(maps interface{}) (int, error) {\n\tvar count int\n\tif err := db.Model(&Tag{}).Where(maps).Count(&count).Error; err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn count, nil\n}\n\n// ExistTagByID determines whether a Tag exists based on the ID\nfunc ExistTagByID(id int) (bool, error) {\n\tvar tag Tag\n\terr := db.Select(\"id\").Where(\"id = ? AND deleted_on = ? \", id, 0).First(&tag).Error\n\tif err != nil && err != gorm.ErrRecordNotFound {\n\t\treturn false, err\n\t}\n\tif tag.ID > 0 {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// DeleteTag delete a tag\nfunc DeleteTag(id int) error {\n\tif err := db.Where(\"id = ?\", id).Delete(&Tag{}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// EditTag modify a single tag\nfunc EditTag(id int, data interface{}) error {\n\tif err := db.Model(&Tag{}).Where(\"id = ? AND deleted_on = ? \", id, 0).Updates(data).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CleanAllTag clear all tag\nfunc CleanAllTag() (bool, error) {\n\tif err := db.Unscoped().Where(\"deleted_on != ? \", 0).Delete(&Tag{}).Error; err != nil {\n\t\treturn false, err\n\t}\n\n\treturn true, nil\n}\n",
      "depend": []
    },
    {
      "code": ")\n\nvar db *gorm.DB\n\ntype Model struct {\n\tID         int `gorm:\"primary_key\" json:\"id\"`\n\tCreatedOn  int `json:\"created_on\"`\n\tModifiedOn int `json:\"modified_on\"`\n\tDeletedOn  int `json:\"deleted_on\"`\n}\n\n// Setup initializes the database instance\nfunc Setup() {\n\tvar err error\n\tdb, err = gorm.Open(setting.DatabaseSetting.Type, fmt.Sprintf(\"%s:%s@tcp(%s)/%s?charset=utf8&parseTime=True&loc=Local\",\n\t\tsetting.DatabaseSetting.User,\n\t\tsetting.DatabaseSetting.Password,\n\t\tsetting.DatabaseSetting.Host,\n\t\tsetting.DatabaseSetting.Name))\n\n\tif err != nil {\n\t\tlog.Fatalf(\"models.Setup err: %v\", err)\n\t}\n\n\tgorm.DefaultTableNameHandler = func(db *gorm.DB, defaultTableName string) string {\n\t\treturn setting.DatabaseSetting.TablePrefix + defaultTableName\n\t}\n\n\tdb.SingularTable(true)\n\tdb.Callback().Create().Replace(\"gorm:update_time_stamp\", updateTimeStampForCreateCallback)\n\tdb.Callback().Update().Replace(\"gorm:update_time_stamp\", updateTimeStampForUpdateCallback)\n\tdb.Callback().Delete().Replace(\"gorm:delete\", deleteCallback)\n\tdb.DB().SetMaxIdleConns(10)\n\tdb.DB().SetMaxOpenConns(100)\n}\n\n// CloseDB closes database connection (unnecessary)\nfunc CloseDB() {\n\tdefer db.Close()\n}\n\n// updateTimeStampForCreateCallback will set `CreatedOn`, `ModifiedOn` when creating\nfunc updateTimeStampForCreateCallback(scope *gorm.Scope) {\n\tif !scope.HasError() {\n\t\tnowTime := time.Now().Unix()\n\t\tif createTimeField, ok := scope.FieldByName(\"CreatedOn\"); ok {\n\t\t\tif createTimeField.IsBlank {\n\t\t\t\tcreateTimeField.Set(nowTime)\n\t\t\t}\n\t\t}\n\n\t\tif modifyTimeField, ok := scope.FieldByName(\"ModifiedOn\"); ok {\n\t\t\tif modifyTimeField.IsBlank {\n\t\t\t\tmodifyTimeField.Set(nowTime)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// updateTimeStampForUpdateCallback will set `ModifiedOn` when updating\nfunc updateTimeStampForUpdateCallback(scope *gorm.Scope) {\n\tif _, ok := scope.Get(\"gorm:update_column\"); !ok {\n\t\tscope.SetColumn(\"ModifiedOn\", time.Now().Unix())\n\t}\n}\n\n// deleteCallback will set `DeletedOn` where deleting\nfunc deleteCallback(scope *gorm.Scope) {\n\tif !scope.HasError() {\n\t\tvar extraOption string\n\t\tif str, ok := scope.Get(\"gorm:delete_option\"); ok {\n\t\t\textraOption = fmt.Sprint(str)\n\t\t}\n\n\t\tdeletedOnField, hasDeletedOnField := scope.FieldByName(\"DeletedOn\")\n\n\t\tif !scope.Search.Unscoped && hasDeletedOnField {\n\t\t\tscope.Raw(fmt.Sprintf(\n\t\t\t\t\"UPDATE %v SET %v=%v%v%v\",\n\t\t\t\tscope.QuotedTableName(),\n\t\t\t\tscope.Quote(deletedOnField.DBName),\n\t\t\t\tscope.AddToVars(time.Now().Unix()),\n\t\t\t\taddExtraSpaceIfExist(scope.CombinedConditionSql()),\n\t\t\t\taddExtraSpaceIfExist(extraOption),\n\t\t\t)).Exec()\n\t\t} else {\n\t\t\tscope.Raw(fmt.Sprintf(\n\t\t\t\t\"DELETE FROM %v%v%v\",\n\t\t\t\tscope.QuotedTableName(),\n\t\t\t\taddExtraSpaceIfExist(scope.CombinedConditionSql()),\n\t\t\t\taddExtraSpaceIfExist(extraOption),\n\t\t\t)).Exec()\n\t\t}\n\t}\n}\n\n// addExtraSpaceIfExist adds a separator\nfunc addExtraSpaceIfExist(str string) string {\n\tif str != \"\" {\n\t\treturn \" \" + str\n\t}\n\treturn \"\"\n}\n",
      "depend": [
        "pkg/setting"
      ]
    },
    {
      "code": "\"\n\ntype Auth struct {\n\tID       int    `gorm:\"primary_key\" json:\"id\"`\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n}\n\n// CheckAuth checks if authentication information exists\nfunc CheckAuth(username, password string) (bool, error) {\n\tvar auth Auth\n\terr := db.Select(\"id\").Where(Auth{Username: username, Password: password}).First(&auth).Error\n\tif err != nil && err != gorm.ErrRecordNotFound {\n\t\treturn false, err\n\t}\n\n\tif auth.ID > 0 {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n",
      "depend": []
    },
    {
      "code": ")\n\ntype Article struct {\n\tModel\n\n\tTagID int `json:\"tag_id\" gorm:\"index\"`\n\tTag   Tag `json:\"tag\"`\n\n\tTitle         string `json:\"title\"`\n\tDesc          string `json:\"desc\"`\n\tContent       string `json:\"content\"`\n\tCoverImageUrl string `json:\"cover_image_url\"`\n\tCreatedBy     string `json:\"created_by\"`\n\tModifiedBy    string `json:\"modified_by\"`\n\tState         int    `json:\"state\"`\n}\n\n// ExistArticleByID checks if an article exists based on ID\nfunc ExistArticleByID(id int) (bool, error) {\n\tvar article Article\n\terr := db.Select(\"id\").Where(\"id = ? AND deleted_on = ? \", id, 0).First(&article).Error\n\tif err != nil && err != gorm.ErrRecordNotFound {\n\t\treturn false, err\n\t}\n\n\tif article.ID > 0 {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\n// GetArticleTotal gets the total number of articles based on the constraints\nfunc GetArticleTotal(maps interface{}) (int, error) {\n\tvar count int\n\tif err := db.Model(&Article{}).Where(maps).Count(&count).Error; err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn count, nil\n}\n\n// GetArticles gets a list of articles based on paging constraints\nfunc GetArticles(pageNum int, pageSize int, maps interface{}) ([]*Article, error) {\n\tvar articles []*Article\n\terr := db.Preload(\"Tag\").Where(maps).Offset(pageNum).Limit(pageSize).Find(&articles).Error\n\tif err != nil && err != gorm.ErrRecordNotFound {\n\t\treturn nil, err\n\t}\n\n\treturn articles, nil\n}\n\n// GetArticle Get a single article based on ID\nfunc GetArticle(id int) (*Article, error) {\n\tvar article Article\n\terr := db.Where(\"id = ? AND deleted_on = ? \", id, 0).First(&article).Error\n\tif err != nil && err != gorm.ErrRecordNotFound {\n\t\treturn nil, err\n\t}\n\n\terr = db.Model(&article).Related(&article.Tag).Error\n\tif err != nil && err != gorm.ErrRecordNotFound {\n\t\treturn nil, err\n\t}\n\n\treturn &article, nil\n}\n\n// EditArticle modify a single article\nfunc EditArticle(id int, data interface{}) error {\n\tif err := db.Model(&Article{}).Where(\"id = ? AND deleted_on = ? \", id, 0).Updates(data).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// AddArticle add a single article\nfunc AddArticle(data map[string]interface{}) error {\n\tarticle := Article{\n\t\tTagID:         data[\"tag_id\"].(int),\n\t\tTitle:         data[\"title\"].(string),\n\t\tDesc:          data[\"desc\"].(string),\n\t\tContent:       data[\"content\"].(string),\n\t\tCreatedBy:     data[\"created_by\"].(string),\n\t\tState:         data[\"state\"].(int),\n\t\tCoverImageUrl: data[\"cover_image_url\"].(string),\n\t}\n\tif err := db.Create(&article).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// DeleteArticle delete a single article\nfunc DeleteArticle(id int) error {\n\tif err := db.Where(\"id = ?\", id).Delete(Article{}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CleanAllArticle clear all article\nfunc CleanAllArticle() error {\n\tif err := db.Unscoped().Where(\"deleted_on != ? \", 0).Delete(&Article{}).Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n",
      "depend": []
    }
  ],
  "jwt": [
    {
      "code": ")\n\n// JWT is jwt middleware\nfunc JWT() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tvar code int\n\t\tvar data interface{}\n\n\t\tcode = e.SUCCESS\n\t\ttoken := c.Query(\"token\")\n\t\tif token == \"\" {\n\t\t\tcode = e.INVALID_PARAMS\n\t\t} else {\n\t\t\t_, err := util.ParseToken(token)\n\t\t\tif err != nil {\n\t\t\t\tswitch err.(*jwt.ValidationError).Errors {\n\t\t\t\tcase jwt.ValidationErrorExpired:\n\t\t\t\t\tcode = e.ERROR_AUTH_CHECK_TOKEN_TIMEOUT\n\t\t\t\tdefault:\n\t\t\t\t\tcode = e.ERROR_AUTH_CHECK_TOKEN_FAIL\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif code != e.SUCCESS {\n\t\t\tc.JSON(http.StatusUnauthorized, gin.H{\n\t\t\t\t\"code\": code,\n\t\t\t\t\"msg\":  e.GetMsg(code),\n\t\t\t\t\"data\": data,\n\t\t\t})\n\n\t\t\tc.Abort()\n\t\t\treturn\n\t\t}\n\n\t\tc.Next()\n\t}\n}\n",
      "depend": [
        "pkg/e",
        "pkg/util"
      ]
    }
  ],
  "main": [
    {
      "code": ")\n\nfunc init() {\n\tsetting.Setup()\n\tmodels.Setup()\n\tlogging.Setup()\n\tgredis.Setup()\n\tutil.Setup()\n}\n\n// @title Golang Gin API\n// @version 1.0\n// @description An example of gin\n// @termsOfService https://github.com/EDDYCJY/go-gin-example\n// @license.name MIT\n// @license.url https://github.com/EDDYCJY/go-gin-example/blob/master/LICENSE\nfunc main() {\n\tgin.SetMode(setting.ServerSetting.RunMode)\n\n\troutersInit := routers.InitRouter()\n\treadTimeout := setting.ServerSetting.ReadTimeout\n\twriteTimeout := setting.ServerSetting.WriteTimeout\n\tendPoint := fmt.Sprintf(\":%d\", setting.ServerSetting.HttpPort)\n\tmaxHeaderBytes := 1 << 20\n\n\tserver := &http.Server{\n\t\tAddr:           endPoint,\n\t\tHandler:        routersInit,\n\t\tReadTimeout:    readTimeout,\n\t\tWriteTimeout:   writeTimeout,\n\t\tMaxHeaderBytes: maxHeaderBytes,\n\t}\n\n\tlog.Printf(\"[info] start http server listening %s\", endPoint)\n\n\tserver.ListenAndServe()\n\n\t// If you want Graceful Restart, you need a Unix system and download github.com/fvbock/endless\n\t//endless.DefaultReadTimeOut = readTimeout\n\t//endless.DefaultWriteTimeOut = writeTimeout\n\t//endless.DefaultMaxHeaderBytes = maxHeaderBytes\n\t//server := endless.NewServer(endPoint, routersInit)\n\t//server.BeforeBegin = func(add string) {\n\t//\tlog.Printf(\"Actual pid is %d\", syscall.Getpid())\n\t//}\n\t//\n\t//err := server.ListenAndServe()\n\t//if err != nil {\n\t//\tlog.Printf(\"Server err: %v\", err)\n\t//}\n}\n",
      "depend": [
        "models",
        "pkg/gredis",
        "pkg/logging",
        "pkg/setting",
        "routers",
        "pkg/util"
      ]
    }
  ]
}